<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZK-Rollups — Simulación Visual Interactiva</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#0b1020; --bg2:#0f1a3a; --card:#151A33; --ink:#eaf0ff; --muted:#9aa3c7;
    --acc:#6cf4db; --acc2:#a98bff; --good:#66e39f; --warn:#ffd166; --bad:#ff6b6b;
    --line:rgba(255,255,255,.12);
    --l1:#6fa8ff; --l2:#45f2d2; --prov:#a98bff; --data:#ffcf66;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--ink);
    background: radial-gradient(1200px 700px at 15% 15%, #101a3a 0%, transparent 55%),
                radial-gradient(1200px 700px at 85% 90%, #0f2a4a 0%, transparent 55%),
                linear-gradient(160deg,var(--bg1),var(--bg2));
  }
  .wrap{max-width:1220px; margin:0 auto; padding:28px 22px 16px}
  header h1{margin:0 0 6px; font-size:28px; font-weight:800; letter-spacing:.3px}
  header p{margin:0; color:var(--muted)}
  .grid{display:grid; grid-template-columns:400px 1fr; gap:20px; margin-top:16px}
  @media (max-width:1020px){ .grid{grid-template-columns:1fr} }

  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,.04), transparent 60%), var(--card);
    border:1px solid var(--line); border-radius:16px; padding:16px; box-shadow:0 10px 28px rgba(0,0,0,.25);
  }
  .panel h2{margin:0 0 10px; font-size:16px; font-weight:800; letter-spacing:.2px}
  .panel h3{margin:8px 0 8px; font-size:13px; font-weight:800; color:#dfe6ff; letter-spacing:.2px}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .sep{height:1px; background:linear-gradient(90deg,transparent,rgba(255,255,255,.12),transparent); margin:12px 0}
  .help{font-size:12px; color:var(--muted)}
  .note{font-size:12px; color:var(--muted); margin-top:4px}

  /* Inputs */
  .f{display:flex; flex-direction:column; gap:6px; margin:6px 0}
  .f label{font-size:12px; color:var(--muted)}
  .f input[type="range"]{width:100%}
  .f input[type="number"]{
    width:140px; padding:8px 10px; border-radius:10px; border:1px solid var(--line);
    background:#0f1430; color:var(--ink); font-weight:700;
  }
  .f .val{font-variant-numeric:tabular-nums; font-weight:800}
  .select{display:flex; gap:6px}
  .option{
    cursor:pointer; padding:8px 12px; border-radius:10px; border:1px solid var(--line);
    background:#0f1430; color:#eaf0ff; font-size:13px; font-weight:700;
  }
  .option.active{background:linear-gradient(135deg,var(--acc),var(--acc2)); color:#0b1125; border-color:transparent}
  .btn{
    cursor:pointer; border:none; padding:10px 14px; font-weight:800; letter-spacing:.2px; border-radius:12px;
    background:linear-gradient(135deg,var(--acc),var(--acc2)); color:#081022; box-shadow:0 8px 22px rgba(108,244,219,.25);
  }
  .btn.ghost{background:transparent; color:var(--ink); border:1px solid var(--line); box-shadow:none}
  .btn.badge{padding:6px 10px; font-size:12px; border-radius:10px}

  .stat-grid{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
  @media (max-width:1020px){ .stat-grid{grid-template-columns:1fr 1fr} }
  .stat{
    background:#0f1430; border:1px solid var(--line); border-radius:12px; padding:10px;
  }
  .k{font-size:12px; color:var(--muted)}
  .v{font-size:18px; font-weight:800}
  .v.good{color:var(--good)} .v.warn{color:var(--warn)} .v.bad{color:var(--bad)}

  /* Canvas area */
  .stage{position:relative; height:520px; border-radius:16px; overflow:hidden; border:1px solid var(--line);
    background: radial-gradient(600px 300px at 50% 100%, rgba(108,244,219,.12), transparent 70%),
                linear-gradient(180deg,#0f1430,#0b1020 55%);
  }
  canvas{display:block; width:100%; height:100%}
  .legend{position:absolute; left:10px; bottom:10px; display:flex; gap:10px; font-size:12px; color:var(--muted)}
  .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
        background:#0e1433; border:1px solid var(--line)}
  .dot{width:10px; height:10px; border-radius:50%}
  .dot.l2{background:var(--l2)} .dot.prov{background:var(--prov)} .dot.l1{background:var(--l1)}
  .dot.data{background:var(--data)}
  .tooltip{
    position:absolute; right:10px; top:10px; max-width:460px; font-size:12px; color:#dbe4ff;
    background:#0f1430cc; border:1px solid var(--line); padding:10px 12px; border-radius:12px; backdrop-filter: blur(6px)
  }
  .footer{margin-top:10px; text-align:center; color:#aab6ea; font-size:12px}
  .credit{margin-top:14px; text-align:center; color:#93a0d7; font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Escalado de Blockchain con ZK-Rollups — Simulación Interactiva</h1>
    <p>Los ZK-rollups agrupan transacciones en L2, generan una <b>prueba de validez</b> y publican en L1 solo <b>datos + prueba</b>. L1 verifica (barato) sin re-ejecutar todo.</p>
  </header>

  <div class="grid">
    <!-- CONTROLES -->
    <section class="panel">
      <h2>Controles</h2>

      <h3>Modo de datos</h3>
      <div class="select" id="mode">
        <div class="option active" data-mode="rollup" title="Datos en L1: máxima seguridad/autocustodia">ZK-Rollup (DA en L1)</div>
        <div class="option" data-mode="validium" title="Datos fuera de L1: más barato, confías en comité/servidor de datos">Validium (DA off-chain)</div>
      </div>

      <div class="sep"></div>
      <h3>Parámetros del Lote</h3>
      <div class="f">
        <label>Tamaño de lote (transacciones por batch): <span class="val" id="valBatch">512</span></label>
        <input type="range" id="batchSize" min="64" max="4096" step="64" value="512">
      </div>
      <div class="f">
        <label>Tasa de llegada a L2 (tx/s): <span class="val" id="valRate">120</span></label>
        <input type="range" id="txRate" min="10" max="1000" step="10" value="120">
      </div>

      <div class="sep"></div>
      <h3>Costos (simplificados)</h3>
      <div class="f">
        <label>Gas por byte de datos (DA): <span class="val" id="valGasPerByte">16</span> gas/byte</label>
        <input type="range" id="gasPerByte" min="0" max="30" step="1" value="16">
        <span class="help">Relevante solo si los datos se publican en L1 (modo ZK-rollup).</span>
      </div>
      <div class="f">
        <label>Bytes por tx (DA eficaz): <span class="val" id="valBytes">12</span> bytes/tx</label>
        <input type="range" id="bytesPerTx" min="4" max="64" step="1" value="12">
      </div>
      <div class="f">
        <label>Gas por verificación de prueba en L1: <span class="val" id="valProofGas">35000</span> gas</label>
        <input type="range" id="proofGas" min="10000" max="100000" step="1000" value="35000">
      </div>
      <div class="f">
        <label>Precio del gas: <span class="val" id="valGwei">12</span> gwei</label>
        <input type="range" id="gasPrice" min="1" max="200" step="1" value="12">
      </div>

      <div class="sep"></div>
      <h3>Precio de ETH</h3>
      <div class="row">
        <div class="f">
          <label>ETH (USD):</label>
          <input type="number" id="ethPrice" value="3000" min="100" step="10">
        </div>
        <button class="btn badge" data-eth="1500">$1.5k</button>
        <button class="btn badge" data-eth="3000">$3k</button>
        <button class="btn badge" data-eth="4500">$4.5k</button>
      </div>

      <div class="sep"></div>
      <h3>Prover / Verificación</h3>
      <div class="f">
        <label>Tiempo base de prueba por lote (segundos): <span class="val" id="valProverBase">2.0</span>s</label>
        <input type="range" id="proverBase" min="0.2" max="6" step="0.1" value="2.0">
      </div>
      <div class="f">
        <label>Tiempo adicional por 1000 tx (segundos): <span class="val" id="valProverPerK">0.9</span>s</label>
        <input type="range" id="proverPerK" min="0" max="4" step="0.1" value="0.9">
      </div>
      <div class="f">
        <label>Tiempo de verificación on-chain (segundos): <span class="val" id="valVerify">0.3</span>s</label>
        <input type="range" id="verifyTime" min="0.1" max="3" step="0.1" value="0.3">
      </div>

      <div class="sep"></div>
      <div class="row">
        <button class="btn" id="btnStart">Iniciar/Continuar</button>
        <button class="btn ghost" id="btnPause">Pausa</button>
        <button class="btn ghost" id="btnReset">Reiniciar</button>
      </div>

      <div class="sep"></div>
      <h3>Métricas</h3>
      <div class="stat-grid">
        <div class="stat">
          <div class="k">TPS efectivo (L2 → L1)</div>
          <div class="v good" id="mTPS">0.0</div>
        </div>
        <div class="stat">
          <div class="k">Fee por tx (gas)</div>
          <div class="v" id="mFeeGas">0</div>
        </div>
        <div class="stat">
          <div class="k">Fee por tx (ETH / USD)</div>
          <div class="v" id="mFeeEthUsd">0</div>
        </div>
      </div>

      <p class="note">La “finalidad por lote” ≈ <b>tiempo para llenar el lote</b> + <b>tiempo de prueba</b> + <b>verificación en L1</b>.</p>
      <div class="stat" style="margin-top:8px">
        <div class="k">Finalidad por lote (estimada)</div>
        <div class="v warn" id="mFinality">—</div>
      </div>
    </section>

    <!-- ESCENA -->
    <section class="panel stage">
      <div class="tooltip">
        <b>Flujo:</b> Transacciones → <span style="color:var(--l2);font-weight:800">Secuenciador (L2)</span> agrupa en <b>lotes</b> →
        <span style="color:var(--prov);font-weight:800">Prover</span> crea ZK proof →
        <span style="color:var(--l1);font-weight:800">Contrato verificador (L1)</span> valida. <br>
        En modo <b>ZK-rollup</b> publicamos <span style="color:var(--data);font-weight:800">datos en L1</span> (máxima seguridad). En <b>Validium</b> los datos quedan fuera de L1 (más barato, confías en disponibilidad externa).
      </div>
      <canvas id="cv"></canvas>
      <div class="legend">
        <span class="chip"><span class="dot l2"></span> L2 Secuenciador</span>
        <span class="chip"><span class="dot prov"></span> Prover (ZK)</span>
        <span class="chip"><span class="dot data"></span> Datos (DA)</span>
        <span class="chip"><span class="dot l1"></span> L1 Verificador</span>
      </div>
    </section>
  </div>

  <div class="footer">Consejo: sube el <b>tamaño de lote</b> y verás bajar el <b>fee por tx</b> (mejor amortización), pero la <b>finalidad</b> puede empeorar si la tasa de llegada es baja. Cambia a <b>Validium</b> y compara costo vs. confianza en datos.</div>
  <div class="credit">Material elaborado por el profesor Sergio Gevatschnaider</div>
</div>

<script>
/* ========= Utilidades ========= */
const $ = (sel) => document.querySelector(sel);
const fmt = (n, d=1) => Number(n).toFixed(d);
const gweiToEth = (gwei) => gwei * 1e-9;

/* ========= Estado de controles ========= */
const controls = {
  mode: 'rollup',
  batchSize: 512,
  txRate: 120,
  gasPerByte: 16,
  bytesPerTx: 12,
  proofGas: 35000,
  gasPrice: 12,
  proverBase: 2.0,
  proverPerK: 0.9,
  verifyTime: 0.3,
  ethUSD: 3000
};

function bindControls(){
  const updateText = () => {
    $('#valBatch').textContent = controls.batchSize;
    $('#valRate').textContent = controls.txRate;
    $('#valGasPerByte').textContent = controls.gasPerByte;
    $('#valBytes').textContent = controls.bytesPerTx;
    $('#valProofGas').textContent = controls.proofGas;
    $('#valGwei').textContent = controls.gasPrice;
    $('#valProverBase').textContent = controls.proverBase;
    $('#valProverPerK').textContent = controls.proverPerK;
    $('#valVerify').textContent = controls.verifyTime;
    $('#ethPrice').value = controls.ethUSD;
  };
  // sliders
  $('#batchSize').addEventListener('input', e=>{ controls.batchSize = +e.target.value; updateText(); });
  $('#txRate').addEventListener('input', e=>{ controls.txRate = +e.target.value; updateText(); });
  $('#gasPerByte').addEventListener('input', e=>{ controls.gasPerByte = +e.target.value; updateText(); });
  $('#bytesPerTx').addEventListener('input', e=>{ controls.bytesPerTx = +e.target.value; updateText(); });
  $('#proofGas').addEventListener('input', e=>{ controls.proofGas = +e.target.value; updateText(); });
  $('#gasPrice').addEventListener('input', e=>{ controls.gasPrice = +e.target.value; updateText(); });
  $('#proverBase').addEventListener('input', e=>{ controls.proverBase = +e.target.value; updateText(); });
  $('#proverPerK').addEventListener('input', e=>{ controls.proverPerK = +e.target.value; updateText(); });
  $('#verifyTime').addEventListener('input', e=>{ controls.verifyTime = +e.target.value; updateText(); });

  // ETH price
  $('#ethPrice').addEventListener('input', e=>{
    const v = +e.target.value;
    if(!Number.isNaN(v) && v>0) controls.ethUSD = v;
  });
  document.querySelectorAll('[data-eth]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      controls.ethUSD = +btn.dataset.eth;
      $('#ethPrice').value = controls.ethUSD;
    });
  });

  // mode toggles
  $('#mode').querySelectorAll('.option').forEach(el=>{
    el.addEventListener('click', ()=>{
      $('#mode').querySelectorAll('.option').forEach(o=>o.classList.remove('active'));
      el.classList.add('active');
      controls.mode = el.dataset.mode;
      flashData = 1.0; // feedback visual de cambio
    });
  });

  // buttons
  $('#btnStart').addEventListener('click', ()=> running = true );
  $('#btnPause').addEventListener('click', ()=> running = false );
  $('#btnReset').addEventListener('click', ()=> resetSim());

  updateText();
}

/* ========= Métricas (cálculo pedagógico) =========
   Supuestos:
   - Tiempo para llenar lote = batchSize / txRate
   - Tiempo de prueba = proverBase + proverPerK * (batchSize/1000)
   - Verificación on-chain = verifyTime
   - Gas por DA del lote = gasPerByte * bytesPerTx * batchSize (solo en modo rollup)
   - Gas por verificación del lote = proofGas
   - Gas total por tx = (daGasBatch + proofGasBatch) / batchSize
   - Fee/tx ETH = gas/tx * gasPrice(ETH) ; gasPrice(ETH) = gwei * 1e-9
   - Fee/tx USD = Fee/tx ETH * ETH_USD
*/
function computeMetrics(){
  const tFill = controls.batchSize / Math.max(controls.txRate, 0.0001);
  const tProve = controls.proverBase + controls.proverPerK * (controls.batchSize/1000);
  const tVerify = controls.verifyTime;
  const finality = tFill + tProve + tVerify;

  // gas por lote
  const daGasBatch = (controls.mode === 'rollup')
      ? (controls.gasPerByte * controls.bytesPerTx * controls.batchSize)
      : 0;
  const proofGasBatch = controls.proofGas;
  const totalGasBatch = daGasBatch + proofGasBatch;

  const perTxGas = totalGasBatch / Math.max(controls.batchSize,1); // gas/tx
  const gasPriceEth = gweiToEth(controls.gasPrice);                // ETH por gas
  const perTxETH = perTxGas * gasPriceEth;                         // ETH/tx
  const perTxUSD = perTxETH * controls.ethUSD;                     // USD/tx

  // TPS efectivo (por lotes en pipeline)
  const tpsEff = controls.batchSize / finality;

  return { tFill, tProve, tVerify, finality, perTxGas, perTxETH, perTxUSD, tpsEff, daGasBatch, proofGasBatch };
}

/* ========= Escena Canvas ========= */
const canvas = $('#cv');
const ctx = canvas.getContext('2d');
let W=0, H=0;
function resize(){ W = canvas.width = canvas.clientWidth * devicePixelRatio; H = canvas.height = canvas.clientHeight * devicePixelRatio; }
window.addEventListener('resize', resize); resize();

// posiciones
const layout = {
  memX: 80, memY: 80, memW: 280, memH: 110,
  seqX: 420, seqY: 80, seqW: 240, seqH: 110,
  provX: 420, provY: 240, provW: 240, provH: 110,
  l1X: 820, l1Y: 160, l1W: 300, l1H: 130
};

function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function box(x,y,w,h,color,stroke=true){
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,.35)"; ctx.shadowBlur = 16; ctx.shadowOffsetY = 10;
  ctx.fillStyle = color; roundRect(x,y,w,h,16); ctx.fill();
  if(stroke){ ctx.strokeStyle = "rgba(255,255,255,.15)"; ctx.lineWidth = 2; ctx.stroke(); }
  ctx.restore();
}
function arrow(x1,y1,x2,y2,color){
  ctx.save();
  ctx.strokeStyle = color; ctx.lineWidth = 3*devicePixelRatio; ctx.globalAlpha = 0.85;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  const ang = Math.atan2(y2-y1, x2-x1), len = 10*devicePixelRatio;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - len*Math.cos(ang - .3), y2 - len*Math.sin(ang - .3));
  ctx.lineTo(x2 - len*Math.cos(ang + .3), y2 - len*Math.sin(ang + .3));
  ctx.closePath(); ctx.fillStyle = color; ctx.fill();
  ctx.restore();
}
function text(x,y,s,sz=12,color="#cbd3ff",bold=false){
  ctx.fillStyle=color; ctx.font = `${bold?"800":"600"} ${sz*devicePixelRatio}px Inter`; ctx.textBaseline="top"; ctx.fillText(s,x,y);
}

/* ========= Simulación por “ticks” ========= */
let running = false;
let tPrev = performance.now();
let accum = 0;
let mempool = []; // cola de transacciones
let batch = { count:0, state:'fill', t:0, tProve:0, tVerify:0 };
let batchesDone = 0;
let flashData = 0;

function resetSim(){
  running = false;
  mempool = [];
  batch = { count:0, state:'fill', t:0, tProve:0, tVerify:0 };
  batchesDone = 0;
  updateMetricsDisplay();
}

function spawnTx(dt){ // añadir llegada de tx según tasa
  const expected = controls.txRate * dt;
  accum += expected;
  while(accum >= 1){ mempool.push({}); accum -= 1; }
}

function step(dt){
  // Llegadas a L2
  spawnTx(dt);

  // Llenado de lote
  if(batch.state === 'fill'){
    while(batch.count < controls.batchSize && mempool.length>0){
      mempool.pop(); batch.count++;
    }
    if(batch.count >= controls.batchSize){
      // iniciar prueba
      const tProve = controls.proverBase + controls.proverPerK * (controls.batchSize/1000);
      batch.state = 'prove'; batch.t = 0; batch.tProve = tProve;
    }
  }else if(batch.state === 'prove'){
    batch.t += dt;
    if(batch.t >= batch.tProve){
      batch.state = 'verify'; batch.t = 0; batch.tVerify = controls.verifyTime;
      flashData = 1.0; // efecto de "publicación" (DA+proof)
    }
  }else if(batch.state === 'verify'){
    batch.t += dt;
    if(batch.t >= batch.tVerify){
      batchesDone++;
      // nuevo lote
      batch = { count:0, state:'fill', t:0, tProve:0, tVerify:0 };
    }
  }
}

function updateMetricsDisplay(){
  const m = computeMetrics();
  $('#mTPS').textContent = fmt(m.tpsEff,1);
  $('#mFeeGas').textContent = fmt(m.perTxGas,0) + ' gas/tx';
  $('#mFeeEthUsd').textContent = `${fmt(m.perTxETH,6)} ETH  ·  $${fmt(m.perTxUSD,4)}`;
  $('#mFinality').textContent = fmt(m.finality,2) + ' s';
}

function drawBG(){
  const DPR = devicePixelRatio;
  ctx.clearRect(0,0,W,H);
  // títulos
  text(layout.memX*DPR, (layout.memY-26)*DPR, "Mempool L2 (entradas)", 12);
  text(layout.seqX*DPR, (layout.seqY-26)*DPR, "Secuenciador (L2)", 12, "#e1fff8", true);
  text(layout.provX*DPR, (layout.provY-26)*DPR, "Prover ZK (Genera prueba)", 12, "#efe3ff", true);
  text(layout.l1X*DPR, (layout.l1Y-26)*DPR, "Contrato Verificador (L1)", 12, "#e6f0ff", true);

  // cajas
  box(layout.memX*DPR, layout.memY*DPR, layout.memW*DPR, layout.memH*DPR, "#0e1433");
  box(layout.seqX*DPR, layout.seqY*DPR, layout.seqW*DPR, layout.seqH*DPR, "rgba(69,242,210,.18)");
  box(layout.provX*DPR, layout.provY*DPR, layout.provW*DPR, layout.provH*DPR, "rgba(169,139,255,.18)");
  box(layout.l1X*DPR, layout.l1Y*DPR, layout.l1W*DPR, layout.l1H*DPR, "rgba(111,168,255,.18)");

  // flechas
  arrow((layout.memX+layout.memW)*DPR, (layout.memY+layout.memH/2)*DPR, layout.seqX*DPR, (layout.seqY+layout.seqH/2)*DPR, "rgba(69,242,210,.9)");
  arrow((layout.seqX+layout.seqW/2)*DPR, (layout.seqY+layout.seqH)*DPR, (layout.provX+layout.provW/2)*DPR, layout.provY*DPR, "rgba(169,139,255,.9)");

  // publicación a L1 (datos + prueba)
  const col = controls.mode==='rollup' ? "rgba(255,207,102,.95)" : "rgba(169,139,255,.95)";
  arrow((layout.provX+layout.provW)*DPR, (layout.provY+layout.provH/2)*DPR, layout.l1X*DPR, (layout.l1Y+layout.l1H/2)*DPR, col);

  // barras de progreso
  if(batch.state!=='fill'){
    // Prover progress
    const p = batch.state==='prove' ? Math.min(1, batch.t / batch.tProve) : 1;
    ctx.fillStyle = "rgba(169,139,255,.25)";
    ctx.fillRect((layout.provX+12)*DPR, (layout.provY+layout.provH-18)*DPR, (layout.provW-24)*p*DPR, 6*DPR);
  }
  if(batch.state==='verify'){
    const p2 = Math.min(1, batch.t / batch.tVerify);
    ctx.fillStyle = "rgba(111,168,255,.35)";
    ctx.fillRect((layout.l1X+12)*DPR, (layout.l1Y+layout.l1H-18)*DPR, (layout.l1W-24)*p2*DPR, 6*DPR);
  }

  // efecto de datos publicados
  if(flashData>0){
    const a = flashData;
    ctx.save();
    ctx.globalAlpha = a*0.6;
    ctx.fillStyle = controls.mode==='rollup' ? "rgba(255,207,102,.35)" : "rgba(169,139,255,.35)";
    roundRect((layout.l1X-6)*DPR, (layout.l1Y-6)*DPR, (layout.l1W+12)*DPR, (layout.l1H+12)*DPR, 18*DPR); ctx.fill();
    ctx.restore();
    flashData = Math.max(0, flashData - 0.03);
  }

  // mempool tx dots
  const cols = 14, rows = 5, totalCells = cols*rows;
  const n = Math.min(mempool.length, totalCells);
  for(let i=0;i<n;i++){
    const r = Math.floor(i/cols), c = i%cols;
    const x = layout.memX + 16 + c*((layout.memW-32)/(cols-1));
    const y = layout.memY + 24 + r*((layout.memH-40)/(rows-1));
    ctx.beginPath(); ctx.fillStyle = "rgba(108,244,219,.9)"; ctx.arc(x*DPR, y*DPR, 3.2*DPR, 0, Math.PI*2); ctx.fill();
  }

  // lote en secuenciador
  const ratio = batch.count / controls.batchSize;
  const filled = Math.round(ratio * (cols*rows));
  for(let i=0;i<Math.min(filled,totalCells);i++){
    const r = Math.floor(i/cols), c = i%cols;
    const x = layout.seqX + 16 + c*((layout.seqW-32)/(cols-1));
    const y = layout.seqY + 24 + r*((layout.seqH-40)/(rows-1));
    ctx.beginPath(); ctx.fillStyle = "rgba(108,244,219,.8)"; ctx.arc(x*DPR, y*DPR, 3.2*DPR, 0, Math.PI*2); ctx.fill();
  }

  // etiquetas rápidas
  const m = computeMetrics();
  text((layout.seqX+12)*DPR, (layout.seqY+layout.seqH-36)*DPR, `Llenado: ${fmt(ratio*100,0)}%`, 12, "#bfefff");
  text((layout.provX+12)*DPR, (layout.provY+layout.provH-36)*DPR, `Prueba: ${batch.state==='prove'? fmt(Math.min(100,batch.t/batch.tProve*100),0): (batch.state==='verify'? "100":"0")}%`, 12, "#e9ddff");
  text((layout.l1X+12)*DPR, (layout.l1Y+12)*DPR, `Verificación on-chain: ${controls.verifyTime}s`, 12, "#dfe8ff");
  text((layout.l1X+12)*DPR, (layout.l1Y+34)*DPR, `Fee/tx: ${fmt(m.perTxGas,0)} gas  ·  ${fmt(m.perTxETH,6)} ETH  ·  $${fmt(m.perTxUSD,4)}`, 12, "#ffe8b7");
  text((layout.l1X+12)*DPR, (layout.l1Y+56)*DPR, `TPS ≈ ${fmt(m.tpsEff,1)}  |  Finalidad ≈ ${fmt(m.finality,1)}s`, 12, "#cfe2ff");
}

function loop(now){
  const dt = Math.min(0.05, (now - tPrev)/1000); // seg
  tPrev = now;

  if(running){ step(dt); }
  drawBG();
  updateMetricsDisplay();
  requestAnimationFrame(loop);
}

/* ========= Init ========= */
bindControls();
resetSim();
requestAnimationFrame(loop);
</script>
</body>
</html>
